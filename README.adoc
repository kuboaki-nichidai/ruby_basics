:linkcss:
:stylesdir: css
:stylesheet: mystyle.css
:twoinches: width='360'
:full-width: width='100%'
:three-quarters-width: width='75%'
:two-thirds-width: width='66%'
:half-width: width='50%'
:half-size:
:one-thirds-width: width='33%'
:one-quarters-width: width='25%'
:thumbnail: width='60'
:imagesdir: images
:sourcesdir: codes
:icons: font
:hide-uri-scheme!:
:figure-caption: 図
:example-caption: リスト
:table-caption: 表
:appendix-caption: 付録
:xrefstyle: short
:section-refsig:
:chapter-refsig:

:toc:
= Rubyの基礎

Rubyというプログラミング言語と、その基本的な使い方を紹介しておきます。

Rubyの文法が調べたいときは、オンラインリファレンスを参照しましょう。

Rubyのリファレンスマニュアル:: `https://www.ruby-lang.org/ja/documentation/`

バージョンごとに用意してあるので、自分がインストールしたバージョンに近い版を参照するとよいでしょう。


Rubyで何かをしたいとき、どうやればよいか調べたいときは、逆引きサイトを使いましょう。

逆引きRuby:: `https://sites.google.com/site/gyakuhikiruby/`

:sectnums:
:sectnumlevels: 2

== Rubyの概要

=== Rubyはプログラミング言語

Rubyは「まつもと ゆきひろ」さんが、手軽にオブジェクト指向でプログラミングするための言語として、個人で開発を始めたフリーソフトウェアのプログラミング言語です。
現在では、世界中の非常にたくさんの人が利用している、よく知られた言語の1つとなっています。
日本発のソフトウェアということもあって、書籍やインターネット上に日本語の情報がたくさんあります。

=== Rubyはスクリプト言語

プログラミング言語には、プログラムを実行する前にあらかじめ変換を済ませておく「コンパイラ型言語」と、実行が指示されたあとでプログラムを変換する「インタプリタ型言語」があります。
Rubyはインタプリタ型のプログラミング言語の仲間です。

Rubyは、このスクリプト言語の仲間としてもよく知られています。
コンピュータ上で動作する他のプログラムやライブラリを、自分が意図した台本（スクリプト）どおりに実行させるというわけです。
スクリプト言語には、RubyのほかにLinuxのシェルに使われているBashや、Perl、Python、PHP、JavaScriptなどがあります。
スクリプト言語は、すぐに実行できてテストや変更が容易なことから、技術や要求の変化が激しいWebアプリケーションの開発などによく利用されています。

Rubyは、PerlやPythonと同じように、文字列の処理が得意な言語です。
そのため、電子メールやWebアプリケーションのような、文字列の送受信を中心としたネットワークアプリケーションの世界でよく使われています。

=== Rubyはオブジェクト指向プログラミング言語

==== オブジェクトとメッセージの世界

Rubyは、プログラムを作るときの考え方として「オブジェクト指向」を採用しています。
オブジェクト指向について解説するのはこの講義の目的ではないので、少しだけ紹介しておきます。

オブジェクト指向の「オブジェクト」は、日本語でいえば「もの」です。
Rubyの世界での「もの」は、私たちが日本語で考える「もの」とは少し違っていて、なんらかの操作ができる対象全般を意味しています。
つまり、操作すると何かしてくれそうなものは、具体的なものだけでなく概念的な存在でも、みんなオブジェクトとみなします。
たとえば、数値や文字列、それらを組み合わせた複合的なデータ（伝票や住所録など）、ファイルやネットワーク、音声や画像、といったものもRubyの世界ではオブジェクトとして扱います。


あるオブジェクトがほかのオブジェクトに処理をしてもらうには「メッセージ」を送ります。
自動販売機で切符を販売する場合を例にして考えてみましょう。
<<message01>> は切符の販売機と切符を買う人がオブジェクトで、切符を買う人が販売機に切符を販売してくれるよう依頼しているところです。

[[message01]]
.切符を買う人と券売機の間のメッセージの例（1）
image::IMG_0418.jpg[{three-quarters-width}]


このようなとき、オブジェクト指向の世界では、買う人から販売機へ「切符を販売する」というメッセージを送るといいます。
このメッセージを受け取った販売機は、メッセージにしたがって切符を発行し販売する処理をするでしょう。

みなさんの中には、 <<massage02>> のように買う人から、自動販売機へは「切符を購入する」というメッセージを送るのではないのか、と考える人もいませんか。

[[message02]]
.切符を買う人と券売機の間のメッセージの例（2）
image::IMG_0420.jpg[{three-quarters-width}]

でも、ちょっと考えてみてください。
切符を購入するのは人の方で、販売機はこの人に切符を販売するのですよね。
みなさんが窓口で買うときのことを思い出してみてください。
みなさんは窓口の人に「上野から青森までの乗車券を（売って）ください。」などといいませんか。
これがメッセージです。
メッセージは、相手にやってほしいことを頼むようにして送るものなのですね。

では、 <<message03>> 次の図のように販売機がジュースの自動販売機であったらどうでしょうか。
この販売機は「切符を販売する」というメッセージに応えて処理したくても処理できませんね。
このようなとき、Rubyでは「メッセージを処理するメソッドが見つからない」という例外処理を発生します。

[[message03]]
.切符を買う人とジュースの販売機の間のメッセージの例
image::IMG_0421.jpg[{three-quarters-width}]

==== オブジェクト指向プログラミング

<<message01>> から <<message03>> に登場する、メッセージの送り手のオブジェクトを「センダー」、メッセージの受け取り手のオブジェクトを「レシーバ」と呼びます。
 受け取ったメッセージに応答してレシーバが処理をしますが、この処理を「メソッド」と呼びます。
一般には、メッセージ名と、レシーバがそのメッセージを受け取ったときに処理を実行するメソッドの名前は、一致するとは限りません。
ですが、Rubyでは、メッセージ名をメソッド名に使ってプログラムを書くことが多いようです（ <<sender_reciever_message>> ）。

[[sender_reciever_message]]
.センダーとレシーバ、メッセージの関係
image::IMG_0422.jpg[{three-quarters-width}]

<<message_passing>> は、電動モーターを使った搬送車が前進するときのメッセージの伝播する様子です。
運搬車のメソッド「運搬する」の中で走行制御部にメッセージ「前進する」を送っています。
このとき搬送車はメッセージのセンダー、走行制御部はメッセージのレシーバになっています。
次に走行制御部がメソッド「前進する」の中で左右のモーターコントローラーにメッセージ「正転する」を送っています。
こんどは走行制御部がメッセージのセンダーに、左右のモーターコントローラーがレシーバになっています。

[[message_passing]]
.プログラムはメッセージの伝播で動く
image::IMG_0423.jpg[{three-quarters-width}]

このように、オブジェクトがメッセージを伝播させることで処理が進んでいくプログラムを、オブジェクト指向プログラムといいます。
そして、オブジェクト指向プログラムを作るプログラミング方法のことを、オブジェクト指向プログラミングと呼んでいます。
Rubyは、すべてのデータをオブジェクトとし、オブジェクト同士がメッセージを伝播しながら動作するようにプログラムを作る、オブジェクト指向プログラミング言語なのです。

=== オブジェクト指向がわからないとだめ？

Rubyは、オブジェクト指向プログラムを作る言語ですが、それではオブジェクト指向がわからないと使うことができないのでしょうか。
まつもとさんは、Rubyの原点的書籍である『オブジェクト指向スクリプト言語 Ruby』の中で、「Rubyのススメ」と称していろいろな人にRubyを勧めています。

次のリストはその中からいくつか抜粋したものです。

.まつもとさんがRubyを勧める人（抜粋）
* 手軽にオブジェクト指向してみたい人
* 入門用の言語を探している人
* 使いやすいオブジェクト指向ライブラリがほしい人
* 思いついたアイデアを手早く記述したい人
* 日本人

また、同書の別のページでは「オブジェクト指向をあまり意識しなくてもプログラミングできる」ということも特徴にあげています。
そうすると、みなさんにとってRubyは、これからプログラムを学ぶ人向けで、いろいろなライブラリを使って楽にプログラムを書けて、そんなにオブジェクト指向をわかっていなくても気にしなくて大丈夫な言語といえそうです。

この演習も、あまりオブジェクト指向についてわかっていなくても進められるようにします。
みなさんがRubyの言語仕様について広く詳細に理解していなくても大丈夫ですし、1度に多くのことを学ばなくても少しずつプログラムを作っていきましょう。

== 文字列や数値を表示してみよう

蔵書の管理をするときには、書籍名や著者のような名前がよくでてきます。
また、価格は数値ですし、発行日や購入日は日付なのがわかります。
Rubyの使い始めとして、蔵書のデータとして出てくる文字列や数値や日付を表示する方法を学びましょう。

=== 文字列操作を使おう（String クラス）

まず、蔵書データの書籍名や著者を表すのに使う「文字列」の作り方と操作の方法を覚えましょう。
Rubyで文字列を扱うときには、 `String` という名前のクラスを使います。
クラスがどんなものなのかは、まだわからなくてもかまいません。
文字列を作ったり、作った文字列を修正するような操作には、 `String` クラスが用意している操作（Rubyではメソッドと呼んでいます）を利用するということだけ覚えておきましょう。

==== 【演習】新しい文字列を作る（1）（文字列リテラルを使う）

文字列を使うプログラムを動かしてみましょう（ <<ex0301_rb>> ）。

テキストエディタで、 `codes` ディレクトリの `ex0301.rb` を編集して、次のようなプログラムを書きます。
最初のプログラムですので、手順を少し詳しく書いておきます。

.`ex0301.rb` を作成する
. テキストエディタで、この演習用リポジトリの中の `codes` ディレクトリにあるファイル `ex0301.rb` を開く。
. `ex0301.rb` に、 <<ex0301_rb>> を入力する（日本語コードがUTF-8なのを確認する）。
. ファイルを保存する。

:sourcesdir: hints
[[ex0301_rb]]
.【Ruby】 `ex0301.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0301.rb[]
----
<1> `puts` メソッドは、あらかじめRubyに組み込まれている文字列を表示するメソッド。
--
:sourcesdir: codes

入力できていれば、 <<ex0301_rb_w>> には、入力したファイルの内容が反映されているはずです（つまり、このまま提出できるというわけです）。

[[ex0301_rb_w]]
.【Ruby】 みなさんが作成した `ex0301.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0301.rb[]
----
--

NOTE: 作成できたら、一度コミットします。


では、プログラムを実行してみましょう。
先に手順を書いておきます。実際にやってみた例は <<ex0301_rb_exec>> に示します。

.`ex0301.rb` を実行する
. コマンドプロンプトを起動する。
. この演習用リポジトリの中の `codes` ディレクトリへ移動する。
. コマンドラインからプログラムを実行する。
. 表示を確認する。

[TIP]
.Visual Studio Code を使っている人へのヒント
--
メニューの「Terminal＞New Terminal」でエディタの中にターミナルを開けば、そこでプログラムを動かせます。
--


NOTE: みなさんの演習用リポジトリの名前やcloneした場所は各自で異なるので、 <<ex0301_rb_exec>> では `ruby_basics` がそのリポジトリだと思って読み替えてください。

[[ex0301_rb_exec]]
.【Console】 `ex0301.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki> cd ruby_basics # <1>
C:\Users\kuboaki\ruby_basics> cd codes # <2>
C:\Users\kuboaki\ruby_basics\codes> ruby ex0301.rb # <3>
ようこそ
Welcome
私の好物は'りんご'です。
私は"ドリアン"が苦手です。
----
<1> 演習用リポジトリをcloneした場所（**ディレクトリ名は各自で異なるはずなので注意**）に移動した。
<2> cloneした場所の中の `codes` ディレクトリに移動した。
<3> プログラムを実行した。
--

どうでしょう、みなさんにとって最初のプログラムですが、うまく動いたでしょうか。

コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0301_rb_exec_w>> の部分にペーストします。

[[ex0301_rb_exec_w]]
.【Console】みなさんの `ex0301.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。


Rubyでは、文字列は文字の並びをダブルクォート（ `"` ）またはシングルクォート（ `'` ）で両端を囲んで表します。
<<ex0301_rb>> の登場した `'Welcome'` とか `'ようこそ'` のように、プログラムの中に直接記述した文字列のことを「文字列リテラル」といいます。


[[double_quoted_string_ex]]
.【Ruby】 ダブルクォートで囲まれた文字列リテラルの例
[example]
--
[source,ruby,linenums]
----
"Ruby Programming"
"ここが文字列"
----
--

[[single_quoted_string_ex]]
.【Ruby】 シングルクォートで囲まれた文字列リテラルの例
[example]
--
[source,ruby,linenums]
----
'Ruby Programming'
'ここが文字列'
----
--

練習1のプログラムを実行したとき、プログラムとして書いたときに文字列の両端にあったダブルクォートやシングルクォートは表示されませんでしたね。
両端のクォート文字は、文字列の一部ではなく、文字列の開始と終了を表す「囲み」だからです。

[TIP]
.囲む文字による文字列の違い
--
実は、ダブルクォートで囲まれた文字列とシングルクォートで囲まれた文字列は全く同じというわけではありません。
ダブルクォートで囲まれた文字列では、シングルクォートは文字列の区切り文字ではなく通常の文字として扱われます。
一方、シングルクォートで囲まれた文字列ではダブルクォートは文字列の区切り文字ではなく通常の文字として扱われます。
また、ダブルクォートで囲まれた文字列の中では、エスケープシーケンスの記法を使って改行やタブといった制御文字を指定したり、変数の値を埋め込んだりできるようになっています。
--

プログラム中に新しい文字列を記述すると、見かけが同じ文字列であったとしても、そのたびに別の文字列として扱われます。つまり、メモリ上の別の領域に新しい文字列として作成されます。


==== 【演習】新しい文字列を作る（2）（newメソッドを使う）

文字列を作成する別の方法は、 `String` クラスの `new` メソッド使う方法です（ <<string_new_ex>> ）。
「 `String` クラスの `new` メソッドを呼ぶ」とか「 `String` を `new` する」といった言い方をします。

[[string_new_ex]]
.【Ruby】新しい文字列を作るのに `String` クラスの `new` メソッドを使う
[example]
--
[source,ruby,linenums]
----
String.new("ここが文字列")
String.new('ここも文字列')
----
--

では、 <<ex0301_rb>> と同じ文字列を、今度は `String` クラスの `new` メソッドを使って作ってみましょう（ <<ex0302_rb>> ）。


:sourcesdir: hints
[[ex0302_rb]]
.【Ruby】 `ex0302.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0302.rb[]
----
<1> `puts` メソッドは、あらかじめRubyに組み込まれている文字列を表示するメソッド。
--
:sourcesdir: codes

みなさんは、 <<ex0301_rb_w>> のときと同じように、この演習用リポジトリの中の `codes` ディレクトリにあるファイル `ex0302.rb` を開いて編集します（ <<ex0302_rb_w>> ）。

<<ex0302_rb>> のプログラムを見てみましょう。
最初に `String.new('ようこそ')`とあります。
これは `String` クラスの `new` メソッドを呼び出すことを意味しています。
メソッド名のうしろにカッコで囲んで作成する文字列が書いてあります。
この記法の意味は、 `new` メソッドにデータとして `'ようこそ'` という文字列を渡すということです。
このとき、メソッドに渡すデータのことを引数（ひきすう）またはパラメータといいます。


[[ex0302_rb_w]]
.【Ruby】みなさんが入力した `ex0302.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0302.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。

[[ex0302_rb_exec]]
.【Console】 `ex0302.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0302.rb # <1>
ようこそ
Welcome
私の好物は'りんご'です。
私は"ドリアン"が苦手です。
----
<1> 演習用リポジトリをcloneした場所の `codes` ディレクトリでプログラムを実行した。
--

<<ex0302_rb_w>> の実行結果は <<ex0301_rb_exec>> と同じになったはずですが、みなさんはどうだったでしょうか。

コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0302_rb_exec_w>> に書き込みます。

[[ex0302_rb_exec_w]]
.【Console】みなさんの `ex0302.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。

`new` メソッドだけでなく、Rubyのどのメソッドも、処理に必要な指示や情報を引数を使って渡せます。
メソッドへ渡すデータは、1つとは限りません。
複数の引数をメソッドに渡すときは、カンマ（ `,` ）で区切って並べます。

`String` クラスが `new` メソッドを呼び出す様子を図にすると、 <<string_new_message_passing>> のようになります。
メッセージを受け取っているレシーバは `String` クラス、メッセージは `new` です。
そして、ここでのメッセージの送り手（センダー）は、みなさんのプログラムです。

[[string_new_message_passing]]
.`String` クラスがメッセージ `new` を受け取る様子
image::210424-0003.jpg[{three-quarters-width}]


==== 引数を囲むカッコは省略できる

メソッドの戻り値を使わないのであれば、引数を指定するときにカッコを省略して、 <<omit_parentheses_ex>> のように書くこともできます。

[[omit_parentheses_ex]]
.【Ruby】かっこを省略した引数の書き方
[example]
--
[source,ruby,linenums]
----
String.new "ここが文字列"
String.new 'ここも文字列'
----
--

カッコを使う書き方と使わない書き方のどちらを使ってもかまわないでしょう。
他の人のプログラムを読むときには、両方の書き方があったことを思い出してください。


==== 文字列リテラルとnewメソッド、どちらを使うのか？

文字列の作り方を2通り説明しました。
なぜ書き方が2通りあるのでしょう。それは使うときの事情が異なるからです。
先に説明した文字列リテラルは、プログラムを書いた時点であらかじめどんな文字列を使うのかが決まっているときに便利な方法です。
それに対して、Stringクラスのnewメソッドを使った書き方は、プログラムを実行している途中で作成したい文字列がどんなものになるかが決まるような場合に便利な方法といえるでしょう。
どちらかだけを使うというのではなく、状況に応じて都合のよい書き方を選んで使うというわけです。


=== 文字列に名前をつける（変数名）

<<ex0301_rb>> 、 <<ex0302_rb>> では文字列を作成しました。
文字列を作成すると、コンピュータのメモリ空間のどこかに作成した文字列が格納されているわけです。
しかし、<<ex0301_rb>> や <<ex0302_rb>> のプログラムでは、一度作ってしまった文字列はその後もう一度使いたくても参照する方法がありません。
同じ文字列を使いたくても、別に新しく文字列を作る必要があります。

このことは、文字列ならさほど困らないように思えるでしょうが、数値の計算結果だった場合はどうでしょうか。
<<variable_less_computing>> の左のように、途中までの計算結果をそのあとの計算で使うときに、もう1回そこまでの計算をやり直していては、プログラムはなかなか問題を解くことができないでしょう。
それよりも、右のように途中までの計算結果を使いながら計算した方が便利ですよね。

[[variable_less_computing]]
.計算結果を保存できず何度も計算する様子
image::210425-0001.jpg[{half-width}]

そこで、作成した文字列に「名前」をつけるという方法で、あとから参照できるようにします。
Rubyでは、作成した文字列につける名前のことを「変数名」といいます。
Rubyには、変数のつけ方にルールがありますが、いまのところは、小文字またはアンダースコア「_」で始まる名前をつけておきましょう（ローカル変数という種類の変数になります）。

==== 【演習】文字列に名前をつける（変数名を使う）

文字列に変数で名前をつけ、それを参照するプログラムを作って動かしてみましょう（ <<ex0303_rb>> ）。

sourcesdir: hints
[[ex0303_rb]]
.【Ruby】 `ex0303.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0303.rb[]
----
<1> `str1` という変数名でこの文字列を参照できるようになる。
<2> `str2` という変数名でこの文字列を参照できるようになる。
<3> `str3` は、`str1と` 同じ文字列を参照できるようになる。
<4> 作った文字列を変数名で参照して表示する。
--
:sourcesdir: codes

みなさんは、 <<ex0302_rb_w>> のときと同じように、この演習用リポジトリの中の `codes` ディレクトリにあるファイル `ex0303.rb` を開いて編集します（ <<ex0303_rb_w>> ）。

[[ex0303_rb_w]]
.【Ruby】みなさんが入力した `ex0303.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0303.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。

[[ex0303_rb_exec]]
.【Console】 `ex0303.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0303.rb
ここが文字列
ここも文字列
ここが文字列
----
--

`str3` が `str1` と同じ文字列を表示していることに注意して実行結果を見てください。


コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0303_rb_exec_w>> に書き込みます。

[[ex0303_rb_exec_w]]
.【Console】みなさんの `ex0303.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。

<<ex0303_rb_exec>> は <<str_with_variable_name>> 図のような名前付けをしていることになります。

[[str_with_variable_name]]
.文字列に変数名をつけた様子
image::210425-0002.jpg[{three-quarters-width}]


=== 文字列を表示する（printメソッド）

さて、ここまで文字列を表示する方法として、おまじないのように `puts` メソッドを使っていました。
文字列の表示によく使うもう1つのメソッドが、 `print` メソッドです。


[[print_sample01_rb]]
.【Ruby】 `print` メソッドを使って文字列を表示する
[example]
--
[source,ruby,linenums]
----
print "ここが文字列" # <1>
print 'ここも文字列'

str1 =  "ここが文字列" # <2>
print str1
----
<1> `print` メソッドで文字列を表示した。
<2> 変数を使った例。
--


`puts` メソッドのときもそうでしたが、 `print` メソッドを使うときには、 `String` クラスの `new` メソッドのようにクラスを指定して書いていません。
Rubyには、プログラムを書くときによく使うメソッドについては特別にクラスの指定なく使えるようにしてあります。
このようなメソッドを「組み込みメソッド」と呼んでいます。
他にも組み込みメソッドがたくさん用意してあり、他のプログラミング言語の組み込み関数のように使えます。



==== 【演習】print メソッドを使って文字列を表示する


`print` メソッドを使って文字列を表示するプログラムを動かしてみましょう（ <<ex0304_rb>> ）。

:sourcesdir: hints
[[ex0304_rb]]
.【Ruby】 `ex0304.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0304.rb[]
----
<1> `print` メソッドを使って文字列を表示した。
<2> `print` メソッドを使って変数に割り当てた文字列を表示した。
--
:sourcesdir: codes


みなさんは、 `codes` ディレクトリにあるファイル `ex0304.rb` を開いて編集します（ <<ex0304_rb_w>> ）。

[[ex0304_rb_w]]
.【Ruby】みなさんが入力した `ex0304.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0304.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。

[[ex0304_rb_exec]]
.【Console】 `ex0304.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0304.rb # <1>
ようこそWelcomeここも文字列
----
--

出力がちょっと変わっていることに注意してください。

コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0304_rb_exec_w>> に書き込みます。

[[ex0304_rb_exec_w]]
.【Console】みなさんの `ex0304.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。


うーん、これはどうでしょう。
たしかに作成した文字列は表示できましたが、表示した2つの文字列はつながって表示されてしまいますね。
できれば1つ表示したら改行して2行に分けて表示したいものです。


改行という処理にやってほしいことは、なにか目に見える文字を表示することではありません。
ある文字以降の表示の開始位置を、次行の先頭に変えることです。
このことを実現するために、ディスプレイなどの表示装置は「表示するときには目に見えない制御コード」をプログラムから送ってもらうという方法で表示位置を制御しています。
プログラムを書くとき、目に見えないコードがあると、扱いにくくて不便です。
そこで、多くのプログラミング言語が、この指示を表現するために特別な記法を用意して、制御文字などと呼んでいます。
Rubyの場合、改行の制御文字は `\n` （バックスラッシュは日本語のフォントでは円記号になります）という書き方で表します。
「n」にはnewline（行替え）の意味が込められています。

では、改行するようにプログラムを直してみましょう（ <<ex0305_rb>> ）。


:sourcesdir: hints
[[ex0305_rb]]
.【Ruby】 `ex0305.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0305.rb[]
----
<1> ダブルクオート文字列に `\n` を追加した。
<2> シングルクオート文字列に `\n` を追加した（改行として扱わないはず）。
<3> `+` 演算子を使って、変数で参照した文字列と `\n` を結合して新しい文字列を作って表示した。
--
:sourcesdir: codes

みなさんは、 `codes` ディレクトリにあるファイル `ex0305.rb` を開いて編集します（ <<ex0305_rb_w>> ）。

[[ex0305_rb_w]]
.【Ruby】みなさんが入力した `ex0305.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0305.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。

[[ex0305_rb_exec]]
.【Console】 `ex0305.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0305.rb
ようこそ
Welcome\nここも文字列
----
--

出力が変わっていることに注意してください。

コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0305_rb_exec_w>> に書き込みます。

[[ex0305_rb_exec_w]]
.【Console】みなさんの `ex0305.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。

はい、こんどは改行されて表示されました。

でも、2行目の文字列の後には「\n」がそのまま表示されています。今度はなにが起きているのでしょうか。
これまで、文字列はダブルクォートかシングルクォートで囲った文字の並びとしていましたが、これらは完全に同じではないのです。
実は `\n` のような制御文字は、ダブルクォートで囲った文字列の中では制御文字として扱われます。
一方で、シングルクォートで囲った文字列の中では制御文字として解釈されず、表記したままの文字として扱うことになっています。

ダブルクォートで囲まれた文字列では、「バックスラッシュ記法（改行のような目に見えない制御文字を表す記法）」と「式展開（変数の値を文字越に埋め込む記法）」が有効になります。
シングルクォートで囲まれた文字列では、バックスラッシュそのものを表す「\\」とシングルクォートを表す「\'」以外は、特別な解釈はされず、その文字のまま扱われます。

これからは、バックスラッシュ記法が必要かなど文字列の内容を考えて、ダブルクォートで囲むかシングルクォートで囲むかを使い分けていくとよいでしょう。
なお、クォートには、ダブルクォートとシングルクォート以外にもっと一般化した「%記法」もありますが、ここでは説明を省略します。


.【コラム】組み込みメソッド
****
Rubyは、本文で紹介したprintメソッドの他にも、たくさんの組み込みメソッドを提供しています。よく使うものを紹介しておきましょう。

[[embedded_methods]]
.よく使う組み込みメソッド
[%autowidth,cols="20,80"]
|===
| メソッド名 | 機能内容
| `chop` | 最後に読み込んだ文字列($_)の最後の文字を取り除いた文字列を生成して返す
| `chomp(rs = $/)` | 文字列の末尾から `rs` で指定する改行コードを取り除いた文字列を生成して返す
| `eval(str)` | strをRubyのコードとして解釈し、実行する
| `exec(str)` | strを自分のプロセスと置き換えて実行する
| `exit([result])` | プログラムの終了。 `result` を終了コードとする（省略値は0）
| `gets([rs])` | コマンドライン引数のファイルまたは標準入力からrsを行末文字として1行読む
| `readline([rs])` | `gets` と同じだが `EOF` で例外 `EOFError` を発生させる
| `readlines([rs])` | 引数ファイルの内容を文字列の配列として一気に読み込む
| `sub(x,[y])` | `$_` 中の先頭の `x` を `y` で置換する。 `y` 省略時はブロックの評価値で置換する
| `gsub(x,[y])` | $_中のxをyですべて置換する。y省略時はブロックの評価値で置換する
| `open(path[,mode])` | `mode` をモードとして（省略時は"r"） `path` のファイルをオープンする
| `sprintf(...)` | C言語の `sprintf` とほぼ同じ
| `raise(...)` | 例外を起こす
| `sleep(sec)` | `sec` 秒だけプログラムの実行を停止。`sec` が省略された場合は永遠に停止
| `p(obj)`  | オブジェクトの表示（デバッグに使う）
|===

`[ ]` で囲まれている引数は省略できることを意味します。

`chop`、`chomp`、`gsub`、`sub` メソッドは、処理した結果の新しい文字列を返しますが、元の文字列を変更して同じ処理をする `chop!`、`chomp!`、`gsub!`、`sub!` メソッドもあります。

****


.【コラム】バックスラッシュ記法
****
ダブルクォートで囲った文字列では、改行（ '\n' ）のほかの制御文字も使えます。
これらの記法を「バックスラッシュ記法」といいます。
バックスラッシュ記法と呼ばれるのは、制御文字の始まりがバックスラッシュ「\」（スラッシュと逆向きの斜め線の記号）から始まるからです。
ただし、多くのみなさんが使っている日本語の環境では、バックスラッシュの代わりに「円記号」が表示されると思いますので、日本語環境ではバックスラッシュは円記号で代替されていると考えてください。
バックスラッシュ記法を使うと、制御文字のほか、8進数や16進数の表記、クォートを文字列に含む方法などを表現できるようになります。


[[backslash_notation]]
.バックスラッシュ記法
[%autowidth,cols="20,80"]
|===
| 制御文字等 | 意味
| `\t` | タブ
| `\n` | 改行
| `\r` | 復帰（キャリッジリターン）
| `\f` | 改ページ
| `\b` | バックスペース
| `\a` | ベル
| `\e` | エスケープ
| `\s` | 空白
| `\nnn` | 8 進数表記
| `\xnn` | 16 進数表記
| `\cx` | コントロール文字（x は ASCII 文字）
| `\C-x` | コントロール文字（x は ASCII 文字）
| `\x` | 文字 x そのもの 
|=== 

その昔、改行はタイプライターの紙を1行分送ること（LF：Line Feed）を意味し、復帰（CR：Carriage Return）は印字位置を行頭に移動することを意味していました。
初期のコンピュータの端末はタイプライターそのものといってもよい機器でしたので、復帰や改行の制御用にコードが割り当てられていたわけです。
****


=== 数値と四則演算を使おう（Numeric クラス）

価格やページ数などに使う数値と四則演算の方法を覚えましょう。
Rubyで数値を扱うクラスは、 `Numeric` クラスとその仲間です。
仲間のクラスには、整数を扱う `Integer` クラスと浮動小数点数を扱う `Float` クラスがあります。

==== 新しい数値を作る（数値リテラルを使う）

`1200` とか `3.14`のような数を示すデータが「数値」です。
Rubyでは、数値は数字や小数点の並びで表します。
プログラム中に次のように数値を記述すると、そのたびに新しい数値を作成することになります。
このようにプログラムの中に直接記述できる数値列のことを「数値リテラル」といいます。

[[integer_sample01_rb]]
.【Ruby】 数値リテラルの例（整数）
[example]
--
[source,ruby,linenums]
----
541              # <1>
145              # <2>
0b10010001       # <3>
0221             # <4>
0x91             # <5>
----
<1> 100番目の素数。
<2> 10進数。
<3> 145の2進数表現。
<4> 145の8進数表現。
<5> 145の16進数表現。
--

浮動小数点数や指数表現も扱えます。

[[float_sample01_rb]]
.【Ruby】 数値リテラルの例（浮動小数点数）
[example]
--
[source,ruby,linenums]
----
2.7182818284     # <1>
1.9891e30        # <2>
e = 2.7182818284 # <3>
prime100 = 541   # <4>
----
<1> 自然対数の底。
<2> 太陽の質量（kg）1.9891の10の30乗を表している。
<3> 自然対数の底の値に `e` という名前をつけた。
<4> 100番目の素数に `prime100` という名前をつけた。
--

==== 四則演算

数値では、四則演算、剰余、べき乗の計算ができます。
演算する数が整数か浮動小数点数かで、それぞれの演算も数値の型に合ったの演算になります。
剰余は除算の余りを求める演算で、べき乗は左辺の数を右辺の回数だけ掛けた数を求める演算です。
変数を使うこともできます。

[[numarical_operation_list]]
.四則演算、剰余、べき乗の演算子
[%autowidth,cols="20,80"]
|===
| 演算 | 演算子
| `+` | 加算
| `-` | 減算
| `*` | 乗算
| `/` | 除算
| `%` | 剰余
| `**` | べき乗
|===


==== 【演習】数値や計算結果を表示する(1) （四則演算）

四則演算を試すプログラムを作って動かしてみましょう（ <<ex0306_rb>> ）。


:sourcesdir: hints
[[ex0306_rb]]
.【Ruby】 `ex0306.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0306.rb[]
----
--
:sourcesdir: codes


みなさんは、 `codes` ディレクトリにあるファイル `ex0306.rb` を開いて編集します（ <<ex0306_rb_w>> ）。

[[ex0306_rb_w]]
.【Ruby】みなさんが入力した `ex0306.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0306.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。


[[ex0306_rb_exec]]
.【Console】 `ex0306.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0306.rb
56.1
-11.8
60.0
0.8333333333333334
1
e=2.7182818284
eの2倍は5.4365636568です。
100番目の素数は541です。
----
--


コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0306_rb_exec_w>> に書き込みます。

[[ex0306_rb_exec_w]]
.【Console】みなさんの `ex0306.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。

行の折返しが希望どおりできているか確認してください。


==== 【演習】数値や計算結果を表示する(2) （printfメソッド）

C言語には、数値や文字列を書式に従って文字列に変換してくれるprintfという関数があり、よく利用されています。
Rubyの組み込みメソッドにもこの関数と同様の `printf` メソッドが用意されています。
このメソッドは、第1引数に出力する文字列の書式を指定するための書式指定文字列を渡します。

`printf` メソッドを使うプログラムを作って動かしてみましょう（ <<ex0307_rb>> ）。


:sourcesdir: hints
[[ex0307_rb]]
.【Ruby】 `ex0307.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0307.rb[]
----
--
:sourcesdir: codes


みなさんは、 `codes` ディレクトリにあるファイル `ex0307.rb` を開いて編集します（ <<ex0307_rb_w>> ）。

[[ex0307_rb_w]]
.【Ruby】みなさんが入力した `ex0307.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0307.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。

[[ex0307_rb_exec]]
.【Console】 `ex0307.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0307.rb
20 + 2 = 0022
2 - 20 = -018
2.5 / 3 = 0.833333
9 % 2 = 1
----
--


コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0307_rb_exec_w>> に書き込みます。

[[ex0307_rb_exec_w]]
.【Console】みなさんの `ex0307.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。


.【コラム】printfの書式指定
****
組み込みメソッドの `printf` メソッドや `sprintf` メソッドの書式化文字列の指定方法は、C言語のsprintf関数の書式の指定方法を元に作成されています。
Rubyでは、この書式の指定方法を、元にしたC言語の関数の名前をとって「 `sprintf` フォーマット」と呼びます。

`sprintf` フォーマットの書式は <<sprintf_format_outline>> のような形式になっています。
このうち `[` と `]` で囲まれた部分は、省略可能な要素を意味します。

[[sprintf_format_outline]]
.`sprintf` フォーマットの書式の形式
[example]
--
[source,ruby,linenums]
----
%[引数指定$][フラグ][幅][.精度]指示子
----
--

書式指定は `%` に続く記号の組み合わせによってできています。ここでは、基本的でよく使う書式だけ紹介しておきます。

整数を出力するときの書式は `%d` です。
桁数を指定する場合に `%04d` のように指定した桁数と上位桁に0を詰めて出力します。
上位桁の0を省きたいとき（ゼロサプレスといいます）は、 `%4d`とします。

文字列を出力するときの書式は `%s` です。桁数を指定したい場合には `%10s` などとします。

小数形式の浮動小数点数を出力するときの書式は `%f` です。
桁数を指定したい場合には `%4.5f`などとします。
この例の場合、小数点以上の桁数が4桁、小数点以下の桁数が5桁の出力を意味します。

指数を使った浮動小数点数を出力するときの書式は `%e` です。
桁数を指定したい場合には `%10.5e` などとします。この例の場合、有効桁数が5桁という意味になります。

`sprintf` フォーマット」にはもっと多くの書式指定方法があります。
詳しくは http://www.ruby-lang.org/ja/man/html/[Rubyリファレンスマニュアル] の付録にある「 `sprintf` フォーマット」を参照してください。
****


=== メソッドの実行結果や数値を文字列に埋め込む（式展開）

メソッドが処理した結果や数値は、頻繁に文字列に整形して表示します。
そこで、Rubyには便利な方法としてダブルクォートで囲まれた文字列の中に「式展開」するという方法が用意されています。

文字列の中に式展開を記述するには、 <<Expression_expansion_format>> のような書式を使います。


[[Expression_expansion_format]]
.式展開の書式
[example]
--
[source,ruby,linenums]
----
"...ここに文字列....#{式}...ここに文字列..."
----
--

==== 【演習】式展開を使って実行結果を表示する

<<ex0306_rb>> の後半は、式展開を使って書き直せます。
式展開を使って書き直したプログラムを動かしてみましょう（ <<ex0308_rb>> ）。

:sourcesdir: hints
[[ex0308_rb]]
.【Ruby】 `ex0308.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0308.rb[]
----
--
:sourcesdir: codes


みなさんは、 `codes` ディレクトリにあるファイル `ex0308.rb` を開いて編集します（ <<ex0308_rb_w>> ）。

[[ex0308_rb_w]]
.【Ruby】みなさんが入力した `ex0308.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0308.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。


[[ex0308_rb_exec]]
.【Console】 `ex0308.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0308.rb
e= 2.7182818284
eの2倍は、5.4365636568 です。
100番目の素数は541です。
----
--


コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0308_rb_exec_w>> に書き込みます。

[[ex0308_rb_exec_w]]
.【Console】みなさんの `ex0308.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。

式展開が希望どおりできているか確認してください。


<<ex0308_rb>> では、数値や計算の結果を式展開しましたが、式展開の式として使えるのは数値や計算式だけではありません。配列や変数の指定、メソッドの呼び出しなども式展開の式に指定できます。

=== 日付操作を使おう（Date クラス）

発行日や購入日といった日付の使い方を覚えましょう。
Rubyで日付を扱うときには `Date`クラスを使います。
仲間のクラスに、時刻を表す `Time` クラスや、日付と時間も扱える `DateTime` クラスがあります。

`Date` クラスは組み込みクラスライブラリではないので、利用するときには <<>> のような「 `require`宣言」 が必要です。
[[require_dec_sample]]
.`Date` クラスを使うときの準備
[example]
--
[source,ruby,linenums]
----
require 'date'
----
--

日付は、 `2021-10-24` とか `12 Mar 2020` のように、ある時点の日付を示すための固有の表記を使います。

[[date_sample01_rb]]
.【Ruby】 `Date` クラスを使う例
[example]
--
[source,ruby,linenums]
----
require 'date' # <1>

day = Date.today # <2>
puts day.to_s # <3>
puts day      # <4>

hinamatsuri2009 = Date.new( 2009, 3, 3 )  # <5>
kodomo_no_hi2009 = Date.new( 2009, 5, 5 )
puts hinamatsuri2009 # <6>
puts kodomo_no_hi2009
----
<1> `Date` クラスを使うために `date` ライブラリを require した。
<2> 今日の日付を得る `Date` クラスの `today` メソッドを呼び出した。
<3> `day` は日付オブジェクトなので、文字列に変換して表示した。
<4> `puts` は引数のオブジェクトの `to_s` メソッドを呼び出して文字列にしているので、 `to_s` メソッドを省略しても文字列が得られる。
<5> ひな祭りの日付オブジェクトを作った。`Date` クラスの `new` メソッドは、引数として、年、月、日の数値をる。
<6> ひな祭りの日付オブジェクトを表示した。日付オブジェクトの文字列を得るために `to_s` メソッドが使われている。
--

==== 【演習】書式を指定して日付を表示する

`Date` クラスを使って日付を扱うプログラムを作って動かしてみましょう（ <<ex0309_rb>> ）。
表示する書式を指定したい場合には、 `strftime` メソッドが使えます。

:sourcesdir: hints
[[ex0309_rb]]
.【Ruby】 `ex0309.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0309.rb[]
----
<1> `Date` クラスを使うために `date` ライブラリを require した。
<2> `Date` クラスの `new` メソッドを使って日付オブジェクトを作成した。
<3> 「JIS:X 0301」書式の文字列を表示した。
<4> `strftime` をメソッドを使って、書式を指定して表示した。
--
:sourcesdir: codes


みなさんは、 `codes` ディレクトリにあるファイル `ex0309.rb` を開いて編集します（ <<ex0309_rb_w>> ）。

[[ex0309_rb_w]]
.【Ruby】みなさんが入力した `ex0309.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0309.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。

[[ex0309_rb_exec]]
.【Console】 `ex0309.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0309.rb
2012-03-03
H24.03.03 # <1>
2012年03月03日
----
<1> 「JIS:X 0301」書式を使ったので、元号の記号と和暦の年が使われている。
--

コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、v<<ex0309_rb_exec_w>> に書き込みます。

[[ex0309_rb_exec_w]]
.【Console】みなさんの `ex0309.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。

指定した書式で日付文字列を取得できているか確認してください。


=== 配列を使ってみよう（Array クラス）

文字列や数値、日付は、それぞれが単独の値を持つデータでした。
通常アプリケーションは複数のデータを扱うのですから、ひとつずつのデータをいちいち変数として並べていては、処理や管理が煩わしくなってしまいます。
配列は、複数のデータをまとめて扱うときに使うデータ構造の1つで、同じようなデータが繰り返されているときに向いています。

==== Arrayクラスの使い方

Ruby `Array` クラスは、柔軟で使いやすいクラスです。

:sourcesdir: hints
[[array_samole_rb]]
.【Ruby】 `Array` クラスを使う例
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/array_sample.rb[]
----
<1> 初期化データによる文字列の配列。
<2> 初期化データによる数値の配列。
<3> 入れ子になった配列。Rubyの配列は、異なる型の要素を同じ配列に混在できる。
<4> 配列の要素の参照。要素番号は `0` からなので、 `[1][0]` は、 `orange` になる。
--
:sourcesdir: codes

==== 【演習】配列を繰り返し処理する（eachメソッド）

配列の要素を1つずつ繰り返し処理するには、 `Array` クラスの `each` メソッドを使います。
`each` メソッドは、配列から要素を1つずつ取り出し、後に続くブロックで与えられたプログラムを実行します。
このメソッドを使うと、要素ごとに表示するとか、すべての要素の値を足しこむといった処理ができます。

`Array` クラスの `each` メソッドを使ったプログラムを作って動かしてみましょう（ <<ex0310_rb>> ）。

:sourcesdir: hints
[[ex0310_rb]]
.【Ruby】 `ex0310.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0310.rb[]
----
<1> 配列の要素を1つずつ取り出すために、 `each` メソッドを使った。 `fruits_prices` は「配列の配列」なのに注意。取り出した1件分は `fp` という名前で参照している。これは `['apple', 200]` のような配列になる。
<2> `fp[1]` は `['apple', 200]` のような配列なので、その（0から数えて）1番目の要素は `200` になる。それを変数 `sum` に足している。
--
:sourcesdir: codes


みなさんは、 `codes` ディレクトリにあるファイル `ex0310.rb` を開いて編集します（ <<ex0310_rb_w>> ）。

[[ex0310_rb_w]]
.【Ruby】みなさんが入力した `ex0310.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0310.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。

[[ex0310_rb_exec]]
.【Console】 `ex0310.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0310.rb
名前：apple、値段：200円
名前：orange、値段：100円
名前：melon、値段：600円
1個ずつ買うと全部で900円です。
----
--

コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0310_rb_exec_w>> に書き込みます。

[[ex0310_rb_exec_w]]
.【Console】みなさんの `ex0310.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。

配列の要素を1件ずつ取り出して処理できていることを確認してください。


=== ハッシュを使ってみよう（Hash クラス）

たいていのアプリケーションでは、複数のデータをまとめて扱うための方法が必要です。
まとめて扱う方法を提供するクラスのことを一般に「コレクションクラス」と呼びます。
その1つが、配列（ `Array` クラス）でした。
もう1つのよく使われているクラスが「ハッシュ（ `Hash` クラス）」です。ハッシュは「連想配列」とも呼ばれてます。


==== ハッシュの考え方

配列は、要素を特定するために「何番目」という値を情報として使います。
この要素を特定するための情報のことを「インデックス」や「添字」などと呼びます。
ハッシュは、インデックスとして数値を使う代わりに、文字列やシンボルを使います。
シンボルは、見かけは文字列とよく似ている、目に見えない固有の数値を持った定数です。

配列が「0番目, 1番目 …」と数えるところが、「 `apple` 番目, `orange` 番目 …」となっているとイメージしてみるとよいでしょう（ <<hash_index_image>> ）。その代わり何番目かはわからなくなります。

[[hash_index_image]]
.ハッシュのインデックスのイメージ
image::210426-0001.jpg[{half-width}]

==== Hashクラスの使い方

Rubyのプログラムでは `Hash` クラスはとてもよく使われるクラスです。

:sourcesdir: hints
[[hash_samole_rb]]
.【Ruby】 `Hash` クラスを使う例
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/hash_sample.rb[]
----
<1> 空のハッシュの定義。 `students = Hash.new` のようにも書ける。
<2> 初期化データによるハッシュ。`=>` の前がキー。この例はキーが文字列。
<3> 初期化データによるハッシュ。キーがシンボル。
<4> 初期化データによるハッシュ。キーがシンボルのときはこの記法も使える。
<5> 日付オブジェクトを要素に持つハッシュ。
<6> 既存のハッシュに要素を追加した。
<7> ハッシュから順に要素を取り出す。取り出した要素はキーと値のペアなので、 `key` と `val` の2つの変数で参照している。
<8> ハッシュの中に指定のキーが含まれているか調べた。
--
:sourcesdir: codes


==== 【演習】ハッシュを繰り返し処理する（eachメソッド）

ハッシュの要素を1つずつ繰り返し処理するには、 `Hash` クラスの `each` メソッド（あるいは `each_pair` メソッド）を使います。
`each` メソッドは、ハッシュから要素（キー値のペア）を1つずつ取り出し、後に続くブロックで与えられたプログラムを実行します。
このメソッドを使うと、要素ごとに表示するとか、すべての要素の値を足しこむといった処理ができます。

`Hash` クラスの `each` メソッドを使ったプログラムを作って動かしてみましょう（ <<ex0311_rb>> ）。

:sourcesdir: hints
[[ex0311_rb]]
.【Ruby】 `ex0311.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0311.rb[]
----
<1> 初期化データを使ってハッシュを作成した。キーがシンボルの場合の簡易な表記を使っている。もともとの記法では `:shin => '久保秋 真'` のような表記になる。
<2> キーを指定してハッシュに要素を追加した。
<3> キーを指定してハッシュから要素を取り出した。ハッシュは、キーで要素を一意に検索できる。
<4> キーを指定してハッシュから要素を削除した。
<5> `each` メソッドを使って、キーと値のセットを取り出す。
<6> `printf` メソッドを使ってキーと値を表示した。 `%-8s` は、文字列を8桁幅に左寄せに配置する。  `%8s` なら右寄せになる。
--
:sourcesdir: codes


みなさんは、 `codes` ディレクトリにあるファイル `ex0311.rb` を開いて編集します（ <<ex0311_rb_w>> ）。

[[ex0311_rb_w]]
.【Ruby】みなさんが入力した `ex0311.rb`
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/ex0311.rb[]
----
--

NOTE: 作成できたら、一度コミットします。

では、実行してみましょう。

[[ex0311_rb_exec]]
.【Console】 `ex0311.rb` を実行する
[example]
--
[source,console,linenums]
----
C:\Users\kuboaki\ruby_basics\codes> ruby ex0311.rb
栃窪 孝也
キー：kouya   , 値：栃窪 孝也
キー：astushi , 値：今野 睦
キー：tatsuki , 値：井上 樹
----
--

コマンドプロンプトでみなさんが実行した結果は、テキストとしてコピーしてこの文書（ `README.adoc` ）自身を編集して、<<ex0311_rb_exec_w>> に書き込みます。

[[ex0311_rb_exec_w]]
.【Console】みなさんの `ex0311.rb` の実行結果
[example]
--
[source,console,linenums]
----
ここに、実行結果をテキストとしてコピーしてペーストする。
----
--

NOTE: ペーストできたら、一度コミットします。

ハッシュの要素を1件ずつ取り出して処理できていることを確認してください。

== まとめ

プログラミング言語Rubyの基本的な使い方について学び、いくつかプログラムを作って動かしてみました。
また、オブジェクト指向の考え方やことばについても少し学びました。
